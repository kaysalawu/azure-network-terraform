#cloud-config

package_update: true


write_files:
  - path: /var/lib/spoke/app1/Dockerfile
    owner: root
    permissions: 0744
    content: |
      FROM python:3.12-alpine
      
      WORKDIR /app
      COPY requirements.txt .
      RUN pip install --no-cache-dir -r requirements.txt
      COPY . .
      EXPOSE 8080
      
      CMD ["python", "app.py"]
      
  - path: /var/lib/spoke/app1/app.py
    owner: root
    permissions: 0744
    content: |
      import socket
      from flask import Flask, request
      app = Flask(__name__)
      
      @app.route("/")
      def default():
          hostname = socket.gethostname()
          address = socket.gethostbyname(hostname)
          data_dict = {}
          data_dict['app'] = 'APP1'
          data_dict['hostname'] = hostname
          data_dict['local-ip'] = address
          data_dict['remote-ip'] = request.remote_addr
          data_dict['headers'] = dict(request.headers)
          return data_dict
      
      @app.route("/path1")
      def path1():
          hostname = socket.gethostname()
          address = socket.gethostbyname(hostname)
          data_dict = {}
          data_dict['app'] = 'APP1-PATH1'
          data_dict['hostname'] = hostname
          data_dict['local-ip'] = address
          data_dict['remote-ip'] = request.remote_addr
          data_dict['headers'] = dict(request.headers)
          return data_dict
      
      @app.route("/path2")
      def path2():
          hostname = socket.gethostname()
          address = socket.gethostbyname(hostname)
          data_dict = {}
          data_dict['app'] = 'APP1-PATH2'
          data_dict['hostname'] = hostname
          data_dict['local-ip'] = address
          data_dict['remote-ip'] = request.remote_addr
          data_dict['headers'] = dict(request.headers)
          return data_dict
      
      @app.route("/healthz", host="healthz.az.corp")
      def healthz():
          return "OK"
      
      if __name__ == "__main__":
          app.run(host= '0.0.0.0', port=8080, debug = True)
      
  - path: /var/lib/spoke/app1/dockerignore
    owner: root
    permissions: 0744
    content: |
      Dockerfile
      docker-compose*
      .gitignore
      pyvenv.cfg
      tests
      node_modules/
      npm-debug.log
      bin/
      include/
      lib/
      lib64/
      
  - path: /var/lib/spoke/app1/requirements.txt
    owner: root
    permissions: 0744
    content: |
      Flask==3.0.0
      
  - path: /var/lib/spoke/app2/Dockerfile
    owner: root
    permissions: 0744
    content: |
      FROM python:3.12-alpine
      
      WORKDIR /app
      COPY requirements.txt .
      RUN pip install --no-cache-dir -r requirements.txt
      COPY . .
      EXPOSE 8081
      
      CMD ["python", "app.py"]
      
  - path: /var/lib/spoke/app2/app.py
    owner: root
    permissions: 0744
    content: |
      import socket
      from flask import Flask, request
      app = Flask(__name__)
      
      @app.route("/")
      def default():
          hostname = socket.gethostname()
          address = socket.gethostbyname(hostname)
          data_dict = {}
          data_dict['app'] = 'APP2'
          data_dict['hostname'] = hostname
          data_dict['local-ip'] = address
          data_dict['remote-ip'] = request.remote_addr
          data_dict['headers'] = dict(request.headers)
          return data_dict
      
      @app.route("/path1")
      def path1():
          hostname = socket.gethostname()
          address = socket.gethostbyname(hostname)
          data_dict = {}
          data_dict['app'] = 'APP2-PATH1'
          data_dict['hostname'] = hostname
          data_dict['local-ip'] = address
          data_dict['remote-ip'] = request.remote_addr
          data_dict['headers'] = dict(request.headers)
          return data_dict
      
      @app.route("/path2")
      def path2():
          hostname = socket.gethostname()
          address = socket.gethostbyname(hostname)
          data_dict = {}
          data_dict['app'] = 'APP2-PATH2'
          data_dict['hostname'] = hostname
          data_dict['local-ip'] = address
          data_dict['remote-ip'] = request.remote_addr
          data_dict['headers'] = dict(request.headers)
          return data_dict
      
      @app.route("/healthz", host="healthz.az.corp")
      def healthz():
          return "OK"
      
      if __name__ == "__main__":
          app.run(host= '0.0.0.0', port=8081, debug = True)
      
  - path: /var/lib/spoke/app2/dockerignore
    owner: root
    permissions: 0744
    content: |
      Dockerfile
      docker-compose*
      .gitignore
      pyvenv.cfg
      tests
      node_modules/
      npm-debug.log
      bin/
      include/
      lib/
      lib64/
      
  - path: /var/lib/spoke/app2/requirements.txt
    owner: root
    permissions: 0744
    content: |
      Flask==3.0.0
      
  - path: /var/lib/spoke/docker-compose.yml
    owner: root
    permissions: 0744
    content: |
      version: '3'
      services:
        app1:
          container_name: app1
          build:
            context: ./app1
            dockerfile: Dockerfile
          ports:
            - 8080:8080
          network_mode: host
      
        app2:
          container_name: app2
          build:
            context: ./app2
            dockerfile: Dockerfile
          ports:
            - 8081:8081
          network_mode: host
      
        httpbin:
          image: kennethreitz/httpbin
          ports:
            - 80:80
      
  - path: /var/lib/spoke/service.sh
    owner: root
    permissions: 0744
    content: |
      #! /bin/bash
      
      set -e
      
      base_dir=$(pwd)
      init_dir="/var/lib/spoke"
      log_init="$init_dir/log_init.txt"
      
      if [ ! -d "$init_dir" ]; then mkdir -p "$init_dir"; fi
      
      echo 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf
      echo 'net.ipv6.conf.all.forwarding=1' >> /etc/sysctl.conf
      sysctl -p
      
      sed -i "/#\$nrconf{restart} = 'i';/s/.*/\$nrconf{restart} = 'a';/" /etc/needrestart/needrestart.conf
      
      cat <<EOF > /etc/motd
      ################################################
               Docker Multiport Application
      ################################################
      Docker Ubuntu
       Date:     $(date)
      - Version:  1.0
      - Distro:   $(cat /etc/issue)
      - Packages:
        - Docker
      ################################################
      
      EOF
      
      install_packages() {
          echo "*****************************************"
          echo " Step 0: Install packages"
          echo "*****************************************"
          apt-get update
          apt-get install -y python3-pip python3-dev tcpdump dnsutils net-tools nmap apache2-utils
      
          echo "*****************************************"
          echo " Step 1: Install docker"
          echo "*****************************************"
          apt-get update
          apt-get install -y ca-certificates curl gnupg lsb-release
          mkdir -p /etc/apt/keyrings
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
          $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
          apt-get update
          apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
          echo ""
          docker version
          docker compose version
      
          echo "*****************************************"
          echo " Step 2: Cleanup apt"
          echo "*****************************************"
          apt-get --purge -y autoremove
          apt-get clean
          echo "done!"
      }
      
      start_services() {
        echo "**************************************"
        echo "STEP 1: Start Services"
        echo "**************************************"
        cd "$init_dir"
        echo "docker compose up -d"
        docker compose up -d
        cd "$dir_base"
      }
      
      check_services() {
        echo "**************************************"
        echo "STEP 2: Check Service Status"
        echo "**************************************"
        echo "sleep 3 ..." && sleep 3
        docker ps
        echo ""
        echo "#####################"
        echo "netstat -tupanl|egrep \"80|8080|8081\"|grep -i listen"
        netstat -tupanl|egrep "80|8080|8081"|grep -i listen
      }
      
      systemd_config() {
        echo "**********************************************************"
        echo "STEP 4:  Systemd Service for flaskapp"
        echo "**********************************************************"
        echo "Create: /etc/systemd/system/flaskapp.service"
        cat <<EOF > /etc/systemd/system/flaskapp.service
        [Unit]
        Description=Script for flaskapp
      
        [Service]
        Type=oneshot
        ExecStart=-$init_dir/start.sh
        RemainAfterExit=true
        ExecStop=-$init_dir/stop.sh
        StandardOutput=journal
      
        [Install]
        WantedBy=multi-user.target
      EOF
        cat /etc/systemd/system/flaskapp.service
        systemctl start flaskapp
        systemctl enable flaskapp
      }
      
      install_packages | tee -a "$log_init"
      start_services | tee -a "$log_init"
      check_services | tee -a "$log_init"
      systemd_config | tee -a "$log_init"
      
  - path: /var/lib/spoke/start.sh
    owner: root
    permissions: 0744
    content: |
      #!/bin/bash
      
      set -e
      
      base_dir=$(pwd)
      init_dir="/var/lib/spoke"
      log_service="$init_dir/log_service.txt"
      
      display_delimiter() {
        echo "####################################################################################"
        date
        echo $(basename "$0")
        echo "SYSTEMCTL - Start"
      }
      
      start_services() {
        echo "**************************************"
        echo "STEP 1: Start Services"
        echo "**************************************"
        cd "$init_dir"
        echo "docker compose up -d"
        docker compose up -d
        cd "$dir_base"
      }
      
      check_services() {
        echo "**************************************"
        echo "STEP 2: Check Service Status"
        echo "**************************************"
        echo "sleep 3 ..." && sleep 3
        docker ps
        echo ""
        echo "#####################"
        echo "netstat -tupanl|egrep \"80|8080|8081\"|grep -i listen"
        netstat -tupanl|egrep "80|8080|8081"|grep -i listen
      }
      
      start=$(date +%s)
      display_delimiter | tee -a $log_service
      start_services | tee -a $log_service
      check_services | tee -a $log_service
      end=$(date +%s)
      elapsed=$(($end-$start))
      echo "Completed in $(($elapsed/60))m $(($elapsed%60))s!" | tee -a $log_service
      
  - path: /var/lib/spoke/stop.sh
    owner: root
    permissions: 0744
    content: |
      #!/bin/bash
      
      set -e
      
      base_dir=$(pwd)
      init_dir="/var/lib/spoke"
      log_service="$init_dir/log_service.txt"
      
      display_delimiter() {
        echo "####################################################################################"
        date
        echo $(basename "$0")
        echo "SYSTEMCTL - Start"
      }
      
      stop_services() {
        echo "**************************************"
        echo "STEP 1: Stop Services"
        echo "**************************************"
        cd "$init_dir"
        echo "docker compose down"
        docker compose down
        cd "$dir_base"
      }
      
      check_services() {
        echo "**************************************"
        echo "STEP 2: Check Service Status"
        echo "**************************************"
        echo "sleep 3 ..." && sleep 3
        docker ps
        echo ""
        echo "#####################"
        echo "netstat -tupanl|egrep \"80|8080|8081\"|grep -i listen"
        netstat -tupanl|egrep "80|8080|8081"|grep -i listen
      }
      
      start=$(date +%s)
      display_delimiter | tee -a $log_service
      stop_services | tee -a $log_service
      check_services | tee -a $log_service
      end=$(date +%s)
      elapsed=$(($end-$start))
      echo "Completed in $(($elapsed/60))m $(($elapsed%60))s!" | tee -a $log_service
      


runcmd:
  - . /var/lib/spoke/service.sh
